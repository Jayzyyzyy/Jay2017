# UDP与TCP #

## 一、UDP

###1.UDP的特点

- “尽力而为”服务，UDP段可能：
	- 	丢包
	- 	对应用程序交付失序
- 无连接
	- 在UDP发送方和接收方之间无握手
	- 每个UDP段的处理独立于其他段
- 使用 UDP协议的原因
	- 无连接创建(减少时延)
	- 简单：无连接
	- 段首部小
	- 无拥塞控制: UDP能够尽可能快地传输
- 应用常用于
	- 流式多媒体
	- DNS
	- SNMP

经UDP的可靠传输 : 在应用层增加可靠性，实现特定的差错恢复！

###2.报文格式

![](http://onh97xzo0.bkt.clouddn.com/3-4.PNG)

## 二、TCP

###1.TCP连接

- 面向连接: 
	- 在进行数据交换前，初始化发送方与接收方状态，进行握手(交换控制信息)
	- 连接状态与端系统有关，不为路由器所知 
-全双工数据:
	-同一连接上的双向数据流
- 点到点:
	-一个发送方和一个接收方之间的连接
- 流量控制:
    - 发送方发送速率不能超过接收方能力
- 拥塞控制:
    - 网络拥塞时遏制发送方速率

![](http://onh97xzo0.bkt.clouddn.com/3-5.PNG)

###2.TCP报文段结构

![](http://onh97xzo0.bkt.clouddn.com/3-6.PNG)

###3.TCP序号和确认号

####(1)序号Seq:

	报文段中第1个数据字节在字节流中的位置编号

####(2)确认号ACK

	期望从对方收到下一个字节的序号

![](http://onh97xzo0.bkt.clouddn.com/3-7.PNG)

###4.UDP与TCP各自适用的协议

(1)TCP: FTP HTTP SMTP Telnet

(2)UDP: DNS

## 三、TCP流量控制原理(滑动窗口)

    滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，
	从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。

    利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。分为发送窗口、接收窗口。

###1.发送窗口

滑动窗口: 以字节为单位。(根据B给出的窗口值, A构造出自己的发送窗口)

![](http://onh97xzo0.bkt.clouddn.com/3-9.PNG)

1. 根据接收方B给出的报文中的接受窗口值以及ACK值（ACK字段n表示B对之前n-1个字节的确认，同时表示希望接收到的下一个字节序号是n），发送方A确定出自己的发送窗口。

2. 对于TCP会话的发送方，任何时候在其**发送缓存**内的数据都可以分为4类，“已经发送并得到对端ACK的”，“已经发送但还未收到对端ACK的”，“未发送但对端允许发送的”，“未发送且对端不允许发送”。**“已经发送但还未收到对端ACK的”和“未发送但对端允许发送的”这两部分数据称之为发送窗口**。

3. 发送端窗口在收到ACK后前沿、后沿都向前移动。

当收到接收方新的ACK对于发送窗口中后续字节的确认时(比如ACK=36)，窗口滑动，滑动原理如下图。

![](https://pic1.zhimg.com/9c21786770459afa47bfa2e4606cc454_b.png)

###2.接收窗口

1. 对于TCP的接收方，在某一时刻在它的接收缓存内存在3种。**“已接收”，“未接收准备接收”，“未接收并未准备接收”**（由于ACK直接由TCP协议栈回复，默认无应用延迟，不存在“已接收未回复ACK”）。其中**“未接收准备接收”**称之为接收窗口。

![](http://onh97xzo0.bkt.clouddn.com/3-8.PNG)

2. 接收方的滑动窗口以左，是已经被接收的数据，这部分会被应用进程在合适的时机接收，窗口前沿以右的部分是不允许接收的部分，窗口中的数据，可能包含未按序到达的部分，如果字节序不能连续按序达到，接收方就不会向发送方发送期望收到的字节序号（**接收方只发送连续收到的字节序最大序号的下一个序号值**），当接收方连续收到数据时，窗口后沿会迁移，前沿要么前移要么不动，并且**发送已经确认收到的字节序的下一个序号给发送方（期望收到的字节序序号）**，已经确认收到的部分，在被应用进程接收后，可删除

对于B接收窗口中的字节，可能有些字节还没到达，那么先存下，等待缺少数据的到达。

###3.发送缓存与接收缓存的作用

![](http://onh97xzo0.bkt.clouddn.com/3-10.PNG)
![](http://onh97xzo0.bkt.clouddn.com/3-11.PNG)

- 发送缓存用来暂时存放：
	-  发送应用程序传送给发送方 TCP 准备发送的数据；
	-  TCP 已发送出但尚未收到确认的数据。
- 接收缓存用来暂时存放：
	-  按序到达的、但尚未被接收应用程序读取的数据；
	-  不按序到达的数据。 

## 四、三次握手四次挥手

###1.三次握手

![](http://onh97xzo0.bkt.clouddn.com/3-12.PNG)

- 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
- 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
- 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

###2.四次挥手

![](http://onh97xzo0.bkt.clouddn.com/3-13.PNG)

- 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
- 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
- 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
- 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。


###3.TCP状态

![](http://onh97xzo0.bkt.clouddn.com/3-14.PNG)

![](http://onh97xzo0.bkt.clouddn.com/3-15.PNG)

###4.问题

####(1)为什么time_wait需要等待2MSL(最长报文段寿命)

- 为了保证 A 发送的最后一个 ACK 报文段能够到达B。防止B无法进入CLOSED状态。
- 防止 “已失效的连接请求报文段”出现在本连接中。使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

####(2)为什么需要三次握手，而不是二次、四次？

三次握手能够保证A B之间的可靠传输

1. 四次握手(多了):

	三次握手中B发给A的报文段可以拆为两份报文段，可以先发送一个确认报文段(ACK=1,ack=x+1)，然后再发送一个同步报文段(SYN=1, seq=y),但是效果跟三次握手是一样的，多了一次报文段传输。三次可以提高连接的速度与效率。

2. 二次握手(不够)

	- A 发送同步信号SYN + A's Initial sequence number
	- B发送同步信号SYN + B's Initial sequence number + B's ACK sequence number

A与B就A的初始序列号达成了一致（A可以向B成功发送数据），这里是1000(举例)。但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。(B能否向A成功发送数据就无法保证) **如果B没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。**

####(3)为什么需要四次挥手

保证释放连接的可靠性。