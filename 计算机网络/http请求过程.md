# Http请求的过程

标签（空格分隔）： 计算机网络

---

## 一、TCP/IP四层参考模型
如下图所示，TCP/IP参考模型分为四层：应用层、运输层、网络层和接口层。浏览器所完成的工作就属于应用层的范畴。<br>
![TCP/IP四层参考模型][1]

 - 应用层： 为用户提供各种服务，比如我们浏览网页时用到的HTTP，收发邮件时用的SMTP，登录远程主机用的SSH。
 - 传输层：提供端到端的传输服务。更具体地讲，提供进程到进程的传输服务。
 - 网络层：和传输层一样，可以概括为提供端到端的传输服务。更具体地讲，网络层提供主机到主机的传输服务。
 - 网络接口层（链路层）：为直接连接的设备提供传输服务，将数据帧转换为比特流，并将比特流转换为物理电路的电压高低信号。

## 二、请求与响应过程

### 1.首先，在`chrome`浏览器里输入网址

    
    www.zhihu.com
    
### 2.浏览器根据域名解析IP地址

(1)浏览器必须知道所请求服务器的IP地址，发出的请求才有目的地。DNS(Domain Name System)提供的服务就是将知乎的域名转换成其服务器IP地址。

> 1.一个域中的每个主机名与其IP地址的映射关系由这个域的DNS服务器负责管理，例如，"www.it.org”、“ftp.it.org”、“blog.it.org”等主机名都由管理域“it.org”的DNS服务器进行管理，而不能由管理域“org”的DNS服务器进行管理。

> 2.每个管理域都必须在其直接父域的DNS服务器上注册该子域的名称和该子域的DNS服务器的IP地址，例如，必须在管理域“org”的DNS服务器注册子域“it.org”和其DNS服务器的IP地址后，域名“it.org”才能真正被外界所认可。

> 3.为了方便对顶级域名的统一管理，在顶级域名之上其实还有一个根域名，根域名用点（.）表示，例如，“www.it.org”也可以写为“www.it.org.”，“www.it.org.”中的最后的那个点（.）就表示根域名。

总结来说，大致有三种类型的DNS服务器：**根DNS服务器、顶级DNS服务器和权威DNS服务器**。如下图的层次结构：
![DNS层次结构][2]
除此之外，还有一类重要的DNS，称为**本地DNS服务器**。严格来说本地DNS服务器并不属于DNS服务器的层次结构，但它在整个查询的过程中却扮演着重要的角色。
    
(2)域名解析过程

![域名解析过程][3]

1. 首先，浏览器所在的主机向本地DNS服务器发送一个含有知乎域名的DNS查询报文。
2. 本地DNS服务器把查询报文转发到根DNS服务器，该根DNS服务器注意到其com后缀并向本地DNS服务器返回com的顶级域名服务器的IP地址。
3. 该本地DNS服务器再次向comDNS服务器发送查询请求，com DNS服务器注意到其zhihu.com后缀并用负责该域名的权威DNS服务器的IP地址作为回应。
4. 最后，本地域名服务器将含有http://zhihu.com的IP地址的响应报文发送给客户端主机。

**讨论点1：**

这里的查询过程是包含递归查询和迭代查询的，客户端主机发送给本地服务器的查询是**递归查询**，而后面的三个查询是**迭代查询**。

- 递归查询： 当主机将查询发送给本地域名服务器时，该域名服务器就替代主机处理域名解析的工作，知道返回主机需要的答案，这个答案必须是完整的，不能返回部分答案。
- 递归查询： 根域名服务器(和每个后续的域名服务器)并不是递归继续查询本地域名服务器的。他只是返回部分答案，并移动到下一个操作。本地域名服务器只是负责继续解析，具体做法是发出进一步的查询报文。

**讨论点2：**

在考虑DNS缓存的情况下，缓存中如果有DNS答案就可以直接返回。

- 浏览器缓存：浏览器会缓存DNS记录一段时间。 但操作系统没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。
- 系统缓存：如果在浏览器缓存里没有找到需要的域名，浏览器会做一个系统调用（windows里是gethostbyname），这样便可获得系统缓存中的记录。
- 路由器缓存：如果系统缓存也没找到需要的域名，则会向路由器发送查询请求，它一般会有自己的DNS缓存。
- ISP(互联网服务提供者) DNS缓存：如果依然没找到需要的域名，则最后要查的就是ISP缓存DNS的服务器。在这里一般都能找到相应的缓存记录。

- 高速缓存的答案不具备权威性，域名所做的信息变化不会传播到所有可能知道他的缓存，因此，缓存的表项不能存在太久。

### 3.封装HTTP请求报文

一个http请求报文由请求行<request-line>、请求头部<headers>、空行＜blank-line＞和请求数据＜request-body＞4个部分组成，如下图。

![][6]

具体示例如下：

	
	GET / HTTP/1.1
	Host: zhihu.com
	User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64;
	Accept-Encoding: gzip, deflate
	Connection: Keep-Alive
	

### 4.浏览器与web服务器建立一个 TCP 连接

在应用层和传输层之间，即在浏览器应用服务进程和操作系统提供的TCP服务程序之间，有一个很重要的东西叫做**套接字**（Socket）。套接字与应用层进程绑定。**套接字的作用是实现传输层的多路复用和多路分解。**在应用层可以同时运行多个进程，每个进程都需要通过传输层来收发分组，而传输层的TCP进程只有一个，当TCP进程收到一个分组后，就是通过套接字辨认应用层进程。**多路复用**就是进程将分组通过各自的套接字转发给传输层。**TCP套接字是由一个四元组（源IP地址、源端口号、目的IP地址和目的端口号）来标识的**。

![][4]

**附：TCP三次握手和四次挥手的全过程**

**三次握手：**

第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

**四次挥手：**

与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。

第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。

第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

![][5]

可以简单地认为，**TCP连接创建成功的标志是：客户机和服务器都创建了一个由源IP地址、源端口号、目的IP地址和目的端口号标志的Socket。**

### 5.发送请求

TCP报文段的格式如下图所示。

![][7]

- 目的端口和源端口号是为了在多路复用和多路分解时选择套接字时使用的。
- 数据序号和确认序号是为了传输数据的完整性和顺序而设置的。
- 用户数据这一个字段就存储了应用层生成的HTTP报文。
- ACK、SYN和FIN是在建立连接和关闭连接时使用。

### 6.路由寻址

 现在两个端系统已经建立起了连接，请求也被传送到客户端主机的网络层。网络层是协议栈中最复杂的层次，应用层和传输层只运行在两个端系统，而网络层不仅运行在端系统，还运行在各个中间节点上。

IP数据报的格式：

![][8]

网络层实现的最重要的功能是路由选择，简单地说，就是怎么把这一个IP数据报从客户端主机出发，通过网络中的若干个路由器，到达目的主机。从概念上讲，IP路由选择是简单的，特别对于主机来说，如果目的主机和源主机直接相连（如点对点链路），或都在一个共享网络上（以太网或令牌环网），那么IP数据报就直接送到目的主机上。否则，主机把数据报发送到一默认的路由器上，由路由器来转发该数据报。大多数的主机都采用这种简单机制。

### 7. 服务器“处理”请求并返回响应：

http请求信息经过目标主机网络层，到达应用层，被服务器进程解析。Spring MVC处理请求过程：

具体化：

![](http://img.blog.csdn.net/20141129165243297?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb2xpamluZzIwMTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

具体步骤：

   1、  首先用户发送请求——>DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；<br>

   2、  DispatcherServlet——>HandlerMapping，HandlerMapping 将会把请求映射为 HandlerExecutionChain 对象（包含一个 Handler 处理器（页面控制器）对象、多个 HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；<br>

   3、  DispatcherServlet——>HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；<br>

   4、  HandlerAdapter——>处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个 ModelAndView 对象（包含模型数据、逻辑视图名）；<br>

   5、  ModelAndView 的逻辑视图名——> ViewResolver， ViewResolver 将把逻辑视图名解析为具体的 View，通过这种策略模式，很容易更换其他视图技术；<br>

   6、  View——>渲染，View 会根据传进来的 Model 模型数据进行渲染，此处的 Model 实际是一个 Map 数据结构，因此很容易支持其他视图技术；<br>

   7、  返回控制权给 DispatcherServlet，由 DispatcherServlet 返回响应给用户，到此一个流程结束。

### 8. 释放 TCP 连接

若connection 模式为close，则服务器主动关闭TCP 连接，客户端被动关闭连接，释放TCP 连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

### 9.客户端浏览器解析HTML内容

   客户端将服务器响应的 html 文本解析并显示

### 10.浏览器获取嵌入在HTML中的对象

 在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时浏览器会发送一个获取请求来重新获得这些文件。这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求等等…


    
[1]: https://pic2.zhimg.com/0ff21f5171c24887eba7b2d61f33921d_b.jpg
[2]: https://pic2.zhimg.com/774b521e4a69dc1e4608683ab1fe2005_b.png
[3]: http://img.my.csdn.net/uploads/201211/09/1352475134_4739.png
[4]: https://pic4.zhimg.com/689738410a7c3769fe6de91caa295f1f_b.jpg
[5]: http://images0.cnblogs.com/blog2015/621032/201508/092017231747399.jpg
[6]: http://img.blog.csdn.net/20160523223129990?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center
[7]: https://pic2.zhimg.com/a00b4ab123e2924a8adc7f066e9ebedd_b.jpg
[8]: https://pic3.zhimg.com/dc4fb5eb99f53c98435d6abff8f3e6a6_b.jpg